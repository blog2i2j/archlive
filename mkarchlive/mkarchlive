#!/bin/bash
#########################################################################################
# 本脚本属于 archlive 项目一部分    作者  Carbon Jiao  (Email:  carbonjiao alt gmail dot com)
# 详情 http://archlive.googlecode.com http://archlive-pkg.googlecode.com
# 本脚本自动化创建基于Arch GNU/Linux的Live系统
# 可以创建仅包含zh_CN locale的最精简live系统
# 支持i686 x86_64的目标系统创建, 理论上还支持mips，只要有对应软件仓
# （i686平台可以创建x86_64 Archlive, 反之亦然）
# 支持于任何包含必要软件aufs.ko squash.ko (sqlzma.ko unsqlzma.ko) cdrkit wget links shell
# sed gawk coreutils 及 module-init-tools 的Linux系统 
#  ( Ubuntu Gentoo 等Linux系统也可以创建Archlive）
# 支持全方位定制： 定制启动脚本、定制目标系统软件、定制软件仓、预配置文件。。。
#########################################################################################
#
# 2009-08-25 加入pacman.static 在非Arch环境下也可运行本脚本制作基于Arch GNU/Linux的Live系统。
# 2009-08-24 加入ARCH选项，在i686环境下可以制作x86_64的live系统，反之亦然。
# 2009-08-23 加入附加模块独立制作的支持，加入grub2的支持
# 2009-08-22 加入判断 archlive.conf的模块可以采用加#来去掉，简化更新创建archlive的步骤
# 2009-08-21 加入查找archlive.conf配置文件的文件夹层数限制
# 2009-08-13 检误，并智能化检测、判断制作配置文件archlive.conf
# 2009-08-12 将是否采用overlay个性化定制目录设置放于archlive.conf中
# 2009-08-10 修改运行目录结构，并将模块压缩方式的选择放到配置文件中
# 2009-08-10 修改判断软件仓是否已经在pacman.conf中定义的判断方式
#
APPNAME=$(basename "${0}")
cmdline=$@

error () { echo -e "\033[1;31;40m!!!错误 \033[1;37;40m$@\033[1;0m"; }
warn ()  { echo -e "\033[1;33;40m***警告 \033[1;37;40m$@\033[1;0m"; }
info () { echo -e "\033[1;33;40m>>> \033[1;37;40m$@\033[1;0m"; }

if [ "$EUID" != "0" ]; then
   error "错误: 必须以root用户运行本制作脚本."
   exit 1
fi

# 挂载aufs文件系统并判断是否已经挂载成功
modprobe aufs
if [ $? -ne 0 ]; then
   error "无法装载aufs文件系统模块,退出。"
   exit 1
fi

# usage: usage <exitvalue>
usage ()
{
   echo " 本制作程序须用管理员身份或者sudo来执行，须要aufs文件系统的支持，同时有cdrkit等软件"
   echo " 如果强制使用pacman.static，需确保宿主系统含有 wget links 等程序"
   echo " 请确保archlive制作配置文件archlive.conf存放位置与archlive.conf中指定的PROFILE_DIR一致"
   echo " 注意：输入的选项及命令定义的参数优先性高于配置文件." 
   echo ""
   echo " usage ${APPNAME} [选项] 命令 <命令选项>"
   echo " 一般选项:"
   echo "    -f               强制覆盖现有的工作目录等，全部重新制作"
   echo "    -i CPIO_CONFIG   用CONFIG 作为archlive启动内核配置文件. "
   echo "    -c CDNAME        目标镜像名. 默认: archlive"
   echo "    -b BOOT	     启动选项(syslinux,isolinux,grub,grub-gfx, grub2 默认配置文件中没有提供grub2的菜单文件)"
   echo "    -M MODULES       livecd的模块. "
   echo "    -m MODULESCOPY   从指定的文件夹拷贝附加模块，比如程序模块等. 默认: 无"
   echo "    -a ADDON_DIR     从指定文件夹制作附加设置模块. 默认: 无"
   echo "    -t <iso,img>    目标镜像类型. 默认iso."
   echo "    -v               运行输出结果."
   echo "    -h               本帮助信息."
   echo " 命令:"
   echo "     prepare                   : 准备iso根目录结构及overlay(如果选择需要overlay，在archlive.conf中配置)"
   echo "     modules <工作目录>        : 仅在工作目录下制作独立程序模块, 程序清单在archlive.conf中配置"
   echo "     install <工作目录>        : 将程序安装到工作目录下"
   echo "     squash <工作目录>         : 从指定的目录创建squash模块"
   echo "     bootimage <工作目录>     : 从指定的目录制作archlive启动内核镜像."
   echo "     core_module <工作目录>    : 创建archlive基本模块到工作目录下指定位置."
   echo "     img <工作目录> <目标镜像> : 从指定目录创建目标镜像"
   echo "     all <工作目录> <目标镜像> : 顺序执行以上所有命令"
   exit $1
}

###-------------------------------检测配置----------------------------------------------------
# 根据配置文件archlive.conf存放位置与archlive.conf中PROFILE_DIR定义的值是否一致来判断查找到的配置文件是否是正确
config_is_right () {
   case "${CONFIG_FILE}" in "./${PROFILE_DIR}/archlive.conf") return 0;; esac
   return 1
}
# 装载archlive的配置文件, 从当前目录查看是否存在archlive.conf，存在即调用之
info "开始检测 程序相关配置设置"
#echo "查找配置文件archlive.conf，以第一个符合条件的为制作配置文件"
for config_file in $(find .  -name "archlive.conf"); do
	source ${config_file}
	if [ ! $(config_is_right) ]; then CONFIG_FILE=${config_file} && break; fi
done
if [ "x${CONFIG_FILE}" = "x" ]; then
   error "没有找到正确的配置文件archlive.conf" && usage 1 | tee 
#else
#   echo "载入archlive制作配置文件${CONFIG_FILE}"
fi
source ${CONFIG_FILE}
if [ "x${PROFILE_DIR}" = "x" ]; then
	error "载入配置文件${CONFIG_FILE}失败，请检查配置文件是否已经损坏..."
#else
#	echo "完成."
fi

# 检测、配置输入的命令
while getopts 'i:P:b:M:m:a:t:c:nfvh' arg; do
   case "${arg}" in
	i) CPIOCONFIG="${OPTARG}" ;;
	b) BOOT="${OPTARG}" ;;
	M) MODULES="${OPTARG}" ;;
	m) MODULESCOPY="${OPTARG}" ;;
	a) ADDON_DIR="${OPTARG}" ;;
	t) IMG_TYPE="${OPTARG}" ;;
	c) CDNAME="${OPTARG}" ;;
	f) FORCE="y" ;;
	v) QUIET="n" ;;
        h|?) usage 0 ;;
        *) echo "无效参数 '${arg}'"; usage 1 ;;
   esac
done

#echo "输入的选项及命令: $cmdline"
shift $(($OPTIND - 1))

CMD_NAME="${1}"
case "${CMD_NAME}" in
   prepare) DESCRIPTION="准备工作: 准备安装程序，准备镜像目录结构，Overlay目录等.";;
   modules) WORK_DIR="${2}"; RE_EXTRAMODULES="y"; DESCRIPTION="在工作目录下制作独立程序模块：安装后用squash压缩." ;;
   install*) WORK_DIR="${2}"; RE_EXTRAMODULES="n" ; DESCRIPTION="将程序清单或者附加模块指定的程序安装到工作目录." ;;
   squash*) WORK_DIR="${2}"; RE_EXTRAMODULES="n"; DESCRIPTION="将工作目录中的程序用squash压缩为模块." ;;
   core_module) WORK_DIR="${2}"; DESCRIPTION="创建archlive基本模块到工作目录下指定位置." ;;
   boot*) WORK_DIR="${2}"; DESCRIPTION="从指定的目录制作archlive启动内核模块及基本模块等" ;;
   img) WORK_DIR="${2}"; IMGNAME="${3}"; DESCRIPTION="将工作目录对应目录制作为iso或者img镜像." ;;
   all) WORK_DIR="${2}"; IMGNAME="${3}"; DESCRIPTION="根据配置文件或者参数指定的设置制作程序模块并打包为启动镜像." ;;
   *) warn "无效命令 '${CMD_NAME}'"; usage 1 ;;
esac

#START_DIR=$(pwd)
START_DIR=.
PROFILE_DIR="${START_DIR}/${PROFILE_DIR}"
MKINITCPIO="${START_DIR}/mkinitcpio/mkinitcpio"
REPO_ADD="${START_DIR}/../repo-tools/repo-add"

# 如果archlive.conf没有定义则采用如下默认配置

# 包含内核的模块, 如果archlive.conf中没有定义则默认为list中的第一个
if [ "x${KERNEL_MOD}" = "x" ]; then
   KERNEL_MOD="$(ls -1 ${PROFILE_DIR}/$LISTDIR | head -1)"
fi
if [ "x$QUIET" = "x" ]; then QUIET="y"; fi
if [ "x$FORCE" = "x" ]; then FORCE="y"; fi
if [ "x$CDNAME" = "x" ]; then CDNAME="archlive"; fi
if [ "x$CACHE" = "x" ]; then
   if [ -f /etc/pacman.conf ]; then
	CACHE="$(grep "CacheDir" /etc/pacman.conf | awk -F '=' '{print $2}')"
   else
	echo "系统不存在pacman.conf，宿主系统不是Arch, 将创建软件包缓存位置/var/cache/pacman/pkg"
	CACHE="/var/cache/pacman/pkg"
   fi
fi
if [ "x$PUBLISHER" = "x" ]; then PUBLISHER="http://archlive.googlecode.com/"; fi
if [ "x$AUTHOR" = "x" ]; then AUTHOR="Carbon Jiao"; fi
if [ "x$IMG_TYPE" = "x" ]; then IMG_TYPE="iso"; fi

# 检测模块压缩模式
case ${zip_mode} in 
   1) MKSQUASHFS="${START_DIR}/squashfs3/mksquashfs"
      EXT="sqfs"
      OPTION="-nolzma"
      modprobe squashfs
      [ $? -ne 0 ] && error "宿主系统squashfs文件系统模块" && usage 1
      ;;
   2) MKSQUASHFS="${START_DIR}/squashfs3/mksquashfs"
      EXT="lzm"
      OPTION=""
      modprobe sqlzma
      [ $? -ne 0 ] && error "宿主系统squashfs文件系统模块" && usage 1
      ;;
   3) MKSQUASHFS="${START_DIR}/squashfs4/mksquashfs"
      EXT="sqfs"
      OPTION=""
      modprobe squashfs
      [ $? -ne 0 ] && error "宿主系统squashfs文件系统模块" && usage 1
      ;;
esac

# 装载archlive软件仓等相关配置
if [ "x${PACMANCONF}" = "x" ]; then
   PACMANCONF="${PROFILE_DIR}/pacman_${ARCH}.conf"
fi
# 更新安装时候的软件缓存位置
sed -i "s%.*CacheDir.*%CacheDir = $CACHE%g" $PACMANCONF

# 目标镜像启动内核镜像配置文件
if [ "x${CPIOCONFIG}" = "x" ]; then
   CPIOCONFIG="${PROFILE_DIR}/archlive-mkinitcpio.conf"
fi

case $IMG_TYPE in
	iso*) IMG_TYPE="iso" ;;
	img*) IMG_TYPE="img" ;;
	disk*) IMG_TYPE="img" ;;
	cd*) IMG_TYPE="iso" ;;
	*) IMG_TYPE="iso"; echo "无效的目标类型，采用默认的iso";;
esac
case $BOOT in
	isolinux) BOOT="isolinux" ;;
	syslinux) BOOT="syslinux" ;;
	grub2) BOOT="gub2" ;;
	grub*) BOOT="grub" ;;
	*) BOOT="isolinux"; echo "未知的或者暂时不支持的目标镜像引导程序，采用默认的isolinux" ;;
esac

if [ "x${BOOT}" = "x" ]; then BOOT="syslinux"; fi

if [ "x${WORK_DIR}" = "x" ]; then
#   echo "命令行没有指定工作目录，查看配置文件中是否有设置的工作目录"
   WORK_DIR=$(grep WORK_DIR ${CONFIG_FILE} | cut -d "=" -f2)
   if [ "x${WORK_DIR}" = "x" ]; then 
	WORK_DIR="/$(date +%m%d)"
	#echo "配置文件也没有指定工作目录，采用默认设置${WORK_DIR}"
   fi
fi
[ -d ${WORK_DIR} ] && mkdir -p ${WORK_DIR}
if [ "x${IMGNAME}" = "x" ]; then IMGNAME="${WORK_DIR}/archlive-${ARCH}-$(date +%F).iso"; fi

#archlive最终软件清单
PKGFILE="$WORK_DIR/packages.list"

case $cmdline in *-f*) FORCE="y";; esac
###---------------------------程序运行相关目录设置--------------------------------
# 制作的Archlive镜像目录（该文件夹下所有内容全部包含于目标镜像）
IMGROOT="${WORK_DIR}/${ARCH}_img"

# 制作Archlive的aufs文件系统挂载点
UNION="${WORK_DIR}/union"

# Arch软件仓数据库存放位置
SYNC="${WORK_DIR}/sync"

# 制作的Archlive的模块实际存放目录（安装的实际位置）
MODULEDIR="${WORK_DIR}/${ARCH}_modules"

# archlive.conf中定义的EXTRAMODULES的安装位置
EXTRA_MODULES_INS_DIR="${MODULEDIR}/extra_modules"

# 附加独立程序模块EXTRAMODULES的存放位置（sqfs或者lzm模块）
EXTRA_MODULES_TARGET="${IMGROOT}/${CDNAME}/modules/extra_modules"

# archlive.conf 中定义的 EXTRAPACKAGEDIR 的存放位置
EXTRA_PACKAGE_TARGET="${IMGROOT}/${CDNAME}/modules/extra_package"

# 内核模块的安装位置   比如 ${WORK_DIR}/modules/0_000_core  制作启动内核镜像需要此变量
INSTROOT="${MODULEDIR}/$(basename ${KERNEL_MOD} .list)"

# 集成的软件清单
PKGFILE="${IMGROOT}/packages.list"

# 模块软件清单（包含版本信息）目录
PACKLIST="${WORK_DIR}/list"
# .new  存放目前对应模块最新软件清单
# .old  存放运行本脚本前对应模块的软件清单
# .list 存放对应模块更新详情

# 附加模块清单（最终，包含版本信息）
EX_MODULE_LIST=${PACKLIST}/extra_module.list

# 模块安装日志存放目录
BUILDLOG="${WORK_DIR}/log"
# 该目录下
# -current.log 为目前正进行操作的日志
#  -errors.log 为对应模块安装错误日志

echo "---------------${APPNAME} 程序设置结果：-------------------------------"
echo "       ${APPNAME}程序执行操作: ${CMD_NAME}"
echo "                ${DESCRIPTION}"
echo "         Archlive定制配置文件: ${CONFIG_FILE}"
echo "                     目标系统: ${ARCH}"
echo "                     工作目录: ${WORK_DIR}"
if [ "${CMD_NAME}" = "prepare" -o "${CMD_NAME}" = "install" -o "${CMD_NAME}" = "all" ]; then
echo "       目标镜像源文件存放目录: ${IMGROOT} （镜像启动配置文件存放在其下对应目录中）"
fi
if [ "${CMD_NAME}" = "install" -o "${CMD_NAME}" = "all" ]; then
echo "               软件包缓存目录: ${CACHE} "
fi
echo "              pacman.conf文件: ${PACMANCONF}"
if [ "${CMD_NAME}" = "img" -o "${CMD_NAME}" = "all" ]; then
echo "                 目标镜像类型: ${IMG_TYPE}"
echo "                     标镜像名: ${IMGNAME}"
echo "                     启动程序: ${BOOT}"
fi
if [ "${CMD_NAME}" = "squash" -o "${CMD_NAME}" = "modules" -o "${CMD_NAME}" = "all" ]; then
echo "                     模块类型: ${EXT}"
fi
if [ "${CMD_NAME}" = "bootimage" -o "${CMD_NAME}" = "all" ]; then
echo " Archlive启动内核镜像配置文件: ${CPIOCONFIG}"
fi
if [ "${CMD_NAME}" = "core_module" -o "${CMD_NAME}" = "all" ]; then
echo "          基本核心模块存放到: ${IMGROOT}/${CDNAME}/archlive.sqfs"
fi
if [ "${CMD_NAME}" = "bootimage" -o "${CMD_NAME}" = "all" ]; then
echo "          包含内核程序的模块: ${KERNEL_MOD}"
fi
if [ "${CMD_NAME}" = "install" -o "${CMD_NAME}" = "all" ]; then
echo "                    是否覆盖： ${FORCE}"
fi
echo ""
echo "*** 如果以上设置不是你想要的设置，Ctrl+C 终止程序的执行，然后检测相关配置文件. ***"
echo "                        5 秒后开始程序                               "
sleep 5
echo ""
echo ""
echo "-------------现在开始执行 ${APPNAME} ${CMD_NAME}-----------------------"
###--------------------程序、函数、模块----------------------------------------
# 自定义软件仓
# $1 预建立软件仓的位置
# $2 预建立的软件仓的名称
function custom_repo () 
{
   for pkgfile in $(ls $1/*.pkg.tar.gz); do
   	sh ${REPO_ADD} $1/$2.db.tar.gz $pkgfile
    done
    rm -rf $1/$2.db.tar.gz.old
}
function is_in_pacmanconf () 
{
   a=$(cat ${PACMANCONF} | sed -r "s/#.*//")
   case $a in 
	*[$REPO_Name]*) case $a in *file://$REPO*) return 0;; esac
	;;
	esac
   return 1
}

# 将自定义的软件仓加入到PACMANCONF中，默认第一优先
# pacman.conf须是在# and they will be used before the default mirrors.行后开始定义软件仓.
function add_customrepo2pacmanconf ()
{
   sed -i "/# and they will be used before the default mirrors./ a\
	\ \n[${REPO_Name}]\
	\nServer = file://$REPO" ${PACMANCONF}
   echo "将自定义软件仓加入${PACMANCONF}完成"
}

prepare_overlay (){

   info "准备Archlive 系统配置文件目录overlay"
   [ -d ${WORK_DIR}/overlay ] && rm -rf ${WORK_DIR}/overlay
   if [ -d ${PROFILE_DIR}/overlay ]; then
	mkdir -p ${WORK_DIR}/overlay
	cp -rf ${PROFILE_DIR}/overlay/* ${WORK_DIR}/overlay/
   else
      if [ ! -f overlay.tgz ]; then
		echo "下载Archlive附加配置文件overlay.tgz"
		wget -q "${TGZURL}/overlay.tgz"  2>&1 > /dev/null
      fi
      echo "释放Archlive附加配置文件overlay.tgz"
      tar -xzvpf overlay.tgz -C ${WORK_DIR}   2>&1 > /dev/null
   fi
   OVERLAY=${WORK_DIR}/overlay
   for theme in ${THEME}; do 
   	if [ ! -f "${theme}-theme.tgz" ]; then
		echo "下载主题包文件${theme}-theme.tgz"
            	wget -q "${TGZURL}/${theme}-theme.tgz"  2>&1 > /dev/null
       	fi
	[ ! -d ${OVERLAY}/usr/share/themes ] && mkdir -p ${OVERLAY}/usr/share/themes
	echo "释放主题包${theme}-theme.tgz"
       	tar -xzvpf "${theme}-theme.tgz" -C "${OVERLAY}/usr/share/themes/"   2>&1 > /dev/null
   done
   for icon in ${ICON}; do 
   	if [ ! -f "${icon}-icons.tgz" ]; then
		echo "下载图标文件${icon}-icons.tgz"
	  	wget -q "${TGZURL}/${icon}-icons.tgz"  2>&1 > /dev/null
       	fi
	[ ! -d ${OVERLAY}/usr/share/icons ] && mkdir -p ${OVERLAY}/usr/share/icons
	echo "释放图标文件包${icon}-icons.tgz"
       	tar -xzvpf "${icon}-icons.tgz" -C "${OVERLAY}/usr/share/icons/"  2>&1 > /dev/null
   done
   for cursor in ${CURSOR}; do 
    	if [ ! -f "${cursor}-cursor.tgz" ]; then
   		echo "下载鼠标指针文件包${cursor}-cursor.tgz"
       		wget -q "${TGZURL}/${cursor}-cursor.tgz"  2>&1 > /dev/null
	fi
	[ ! -d ${OVERLAY}/usr/share/icons ] && mkdir -p ${OVERLAY}/usr/share/icons
 	echo "释放鼠标指针文件包${cursor}-cursor.tgz"
	tar -xzvpf "${cursor}-cursor.tgz" -C "${OVERLAY}/usr/share/icons/"  2>&1 > /dev/null
   done
   for font in ${EXTRAFONTS}; do 
   	if [ ! -f "${font}-font.tgz" ]; then
		echo "下载附加字体包文件${font}-font.tgz"
        	wget -q "${TGZURL}/${font}-font.tgz"  2>&1 > /dev/null
       	fi
	[ ! -d ${OVERLAY}/usr/share/fonts/TTF ] && mkdir -p ${OVERLAY}/usr/share/fonts/TTF
	echo "释放附加字体包${font}-font.tgz"
       	tar -xzvpf "${font}-font.tgz" -C "${OVERLAY}/usr/share/fonts/TTF/"  2>&1 > /dev/null
   done
   [ -d "${OVERLAY}/home/arch" ] && chown -R arch:users "${OVERLAY}/home/arch" && chmod -R 700 "${OVERLAY}/home/arch"
   [ -d ${OVERLAY}/root ] && chown -R root:root "${OVERLAY}/root" && chmod -R 700 "${OVERLAY}/root"

   info "overlay准备完毕"
}
prepare_pacman (){

   # 检查宿主系统是否存在pacman，如果不存在则下载pacman.static以完成后续操作
   # 如果archlive.conf强制使用静态编译版pacman，则下载pacman.static

   info "准备安装程序 pacman / pacman.static "
   PACMAN="pacman"
   pacman_version=$(${PACMAN} -V | grep "Pacman" | head -1 | tr -s " " | cut -d " " -f 4)
   if [ "${USE_STATIC_PACMAN}" = "y" -o "x${pacman_version}" = "x" ]; then
	[ "${USE_STATIC_PACMAN}" = "y" ] && echo "配置文件${CONFIG_FILE} 设置为强制使用pacman.static"
	[ "x${pacman_version}" = "x" ] && echo "宿主系统不是Arch GNU/Linux, 使用pacman.static代替"
	PKGARG="http://repo.archlinux.fr/${ARCH}"
	#PKGARG="http://repo.archlinux-br.org/${ARCH}"
	if [ ! -f pacman-static-*.pkg.tar.gz ]; then
		echo "现在开始下载pacman.static ..."
		wget -c $PKGARG/$(links -dump $PKGARG | grep "pacman-static-" | cut -d " " -f 1) 2>&1 > /dev/null
	else
		echo "使用$(ls pacman-static-*.pkg.tar.gz)"
	fi
	tar -xzvpf pacman-static*.pkg.tar.gz -C /tmp 2>&1 > /dev/null
	[ -f /tmp/usr/bin/pacman.static ] && PACMAN="/tmp/usr/bin/pacman.static"
	pacman_version=$(${PACMAN} -V | grep "Pacman" | head -1 | tr -s " " | cut -d " " -f 4)
	[ "x$PACMAN" = "x" ] && error "无法找到pacman.static程序，请确认下载的包是否完整!" && usage 1
   fi
   [ "x${pacman_version}" != "x" ] && echo "完成! 安装程序为 $PACMAN, 版本为: ${pacman_version}"
}
cmd_prepare (){

   # 检查是否是升级安装
   if [ "${CMD_NAME}" = "install" ] && [ -d ${WORK_DIR} ]; then
	if [ "x$(find ${WORK_DIR} -type f -name "desc" | grep var/lib/pacman/local)" != "x" ]; then
		if [ "${FORCE}" = "n" ]; then
			error "错误: 工作目录'${WORK_DIR}'中已经安装过软件包, 退出."
			error "      加入 -f 参数或者archlive.conf中设置FORCE="y"来升级安装. "
			exit 1
		else
			info "更新archlive——基于${WORK_DIR}来更新制作archlive."
		fi
   	fi
   fi
   prepare_pacman
   info "创建制作archlive的相关目录"
   [ ! -d ${UNION} ] && mkdir -p "${UNION}"    # {WORK_DIR} 一并被创建
   [ ! -d ${INSTROOT} ] && mkdir -p "${INSTROOT}"
   [ ! -d ${MODULEDIR} ] && mkdir -p "${MODULEDIR}"

   if [  "x$REPO_Name" != "x" -a "x$REPO" != "x" ]; then
       info "建立自定义软件仓..."
       custom_repo ${REPO} ${REPO_Name}
       echo "自定义软件仓建立完成"
       if ! is_in_pacmanconf; then add_customrepo2pacmanconf; fi
   fi

   info "准备目标镜像根目录结构及启动的相关配置文件"
   [ ! -d ${IMGROOT} ] && mkdir -p ${IMGROOT}
   if [ -d ${PROFILE_DIR}/cd-root ]; then
	cp -rf ${PROFILE_DIR}/cd-root/* ${IMGROOT}/
   else
      if [ ! -f cd-root.tgz ]; then
		echo "下载Archlive光盘根目录结构文件cd-root.tgz"
		wget -q "${TGZURL}/cd-root.tgz"  2>&1 > /dev/null
      fi
      echo "释放Archlive光盘根目录结构cd-root.tgz"
      tar -xzvpf cd-root.tgz -C ${IMGROOT}  2>&1 > /dev/null
   fi
   mkdir -p ${IMGROOT}/${CDNAME}/{base,modules,optional,rootcopy}
   echo "完成."

   if [ "${USE_OVERLAY}" = "y" ]; then
	prepare_overlay
   fi

   # 删除下载的 tgz文件
   [ "$DELETE_TGZ" = "y" ] && rm -f ${START_DIR}/*.tgz

   # 软件安装日志文件夹
   [ -d ${BUILDLOG} ] && rm -R ${BUILDLOG}
   mkdir -p ${BUILDLOG}

   info "mkarchlive准备工作完成"
}
function mount_aufs_w () {
   info "将$1以aufs可写模式挂载到${UNION}"
   mount -t aufs -o br:$1=rw aufs ${UNION}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs可写模式挂载到${UNION}."
        usage 1
   else
	info "完成."
   fi
}
function remount_aufs_w () {
   info "将$1以aufs可写模式挂载到${UNION}"
   mount -o remount,add:0:$1=rw aufs ${UNION}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs可写模式挂载到${UNION}."
        usage 1
   else
	info "完成."
   fi
}
function remount_aufs_r () {
   info "将$1以aufs只读模式挂载到${UNION}"
   [ -f ${UNION}/var/lib/pacman/db.lck ] && rm -f ${UNION}/var/lib/pacman/db.lck
   [ -d ${UNION}/dev ] && rm -rf ${UNION}/dev
   mount -o remount,mod:$1=ro aufs ${UNION}
   if [ $? -ne 0 ]; then 
        error "无法将$1以aufs只读模式挂载到${UNION}."
        usage 1
   else
	info "完成."
   fi
}
function sync_database () {
   info "将Arch软件仓库信息更新到${SYNC} ..."
   [ ! -d ${SYNC} ] && mkdir -p "${SYNC}"
   mount_aufs_w "${SYNC}"
   [ ! -d ${UNION}/var/lib/pacman ] && mkdir -p ${UNION}/var/lib/pacman
   [ -f ${UNION}/var/lib/pacman/db.lck ] && rm -f ${UNION}/var/lib/pacman/db.lck
   info "现在开始更新软件仓..."
   $PACMAN -Sy --noprogressbar --noconfirm --config "${PACMANCONF}" -fr "${UNION}"
   remount_aufs_r "${SYNC}"
   info "Arch软件仓库信息更新完成。"
   echo "导出可用软件包清单到${PACKLIST}/available.list"
   find "${SYNC}/var/lib/pacman/sync" -type d -name "*" | sed -r "s|${SYNC}/var/lib/pacman/sync||g" >${PACKLIST}/available.list
   echo "完成."
}

function pac_install () {

   [ ! -d $UNION/dev ] && mkdir -p $UNION/dev
   [ ! -c $UNION/dev/console ] && mknod $UNION/dev/console c 5 1 >/dev/null
   [ ! -c $UNION/dev/null ] && mknod $UNION/dev/null c 1 3 >/dev/null
   [ ! -c $UNION/dev/zero ] && mknod $UNION/dev/zero c 1 5 >/dev/null

   while true; do
	$PACMAN -S -f $pkgname --needed --noconfirm --config "${PACMANCONF}" \
			-r "$UNION"  2>&1 | tee -a ${BUILDLOG}/${mod}-current.log
	if [ $? -ne 0 ]; then
		if [ "x$(grep $pkgname ${PACKLIST}/available.list)" != "x" ]; then
			error "安装$pkgname出错"
			cat ${BUILDLOG}/${mod}-current.log >> ${BUILDLOG}/${mod}-errors.log
			break
		else
			if [ $(echo $pkgname | grep "-") ]; then
				error "现有软件仓中无 $pkgname, 去掉 -* 后再查找"
				pkgname=${pkgname%-*}
			else
				error "现有软件仓中无 $pkgname, 忽略"
			fi
		fi
	else
		#echo "软件包${pkgname} 安装成功! "
		break
	fi
   done
}

function pac_remove () {

   while true; do
	$PACMAN -R -d -n --noprogressbar --needed --noconfirm --config "${PACMANCONF}" \
		-r "$UNION" $pkgname  2>&1 | tee -a ${BUILDLOG}/${mod}-current.log
	if [ $? -ne 0 ]; then
		if [ "x$(ls $UNION/var/lib/pacman/local | grep $pkgname)" != "x" ]; then
			error "卸载$pkgname出错"
			cat ${BUILDLOG}/${mod}-current.log >> ${BUILDLOG}/${mod}-errors.log
			break
		else
			error "$pkgname 还没有安装，无法卸载。"
		fi
	else
		echo "软件包${pkgname} 卸载成功! "
		break
	fi
   done	
}

function pac_clean () {
   info "清理无用文件..."

   echo "清理aufs文件系统临时文件.wh.* "
   for tmp in "$(find ${MODULEDIR} -type f -name .wh.* )"; do rm -f $tmp; done
   echo "完成!"

   echo "删除为宿主系统创建的内核镜像文件..."
   default_image=$(grep "default_image" ${INSTROOT}/etc/mkinitcpio.d/kernel*.preset | cut -d "=" -f2)
   fallback_image=$(grep "fallback_image" ${INSTROOT}/etc/mkinitcpio.d/kernel*.preset | cut -d "=" -f2)
   [ "x${default_image}" != "x" ] && rm -f "${INSTROOT}${default_image}"
   [ "x${fallback_image}" != "x" ] && rm -f "${INSTROOT}${fallback_image}"
   echo "完成!"

   echo "删除pamcan产生的垃圾文件..."
   for tmp in "$(find ${MODULEDIR} -name *.pacnew -name *.pacsave -name *.pacorig)"; do rm -f $tmp; done
   echo "完成!"

   echo "删除指定的文件夹..."
   kill_dirs="dev var/cache/man var/cache/pacman var/log/* var/mail tmp/* initrd ${DELDIR}"
   #for tmp in ${kill_dirs}; do [ -e "${UNION}/${x}" ] && rm -rf "${UNION}/${tmp}"; done
   for tmp in ${kill_dirs}; do
	for tmp_dir in $(find ${MODULEDIR} -type d -name "$(basename $tmp)" | grep "$tmp"); do rm -rf ${tmp_dir}; done
   done
   echo "完成!"

   echo "删除图标缓存文件..."
   for tmp in "$(find ${MODULEDIR} -type f -name *.cache)"; do rm -f $tmp; done
   echo "完成!"

   if [ "${CUT_LOCALE}" = "y" ]; then
	echo "删除${REMAIN_LOCALE}外的语言文件、帮助文件、X语言文件..."
	for tmpdir in $(find ${MODULEDIR} -type d -name "locale"); do
		for tmp in "$(find $tmpdir/* -maxdepth 0 -type d | grep -v "[${REMAIN_LOCALE}]$")"; do rm -rf $tmp; done
	done
   	echo "完成!"
   fi
}

cmd_extramodules_install () {

   info "开始制作附加程序模块——每个模块只有一个软件"
   # 整理附加模块程序清单
   echo $EXTRAMODULES | tr -s " " "\n" | sed -r "s/#.*//g" | sed -r "/^$/d" >${PACKLIST}/extra_module_0.list
   # 初始化附加模块安装目录
   [ -d ${EXTRA_MODULES_INS_DIR} ] && rm -rf ${EXTRA_MODULES_INS_DIR} && mkdir -p ${EXTRA_MODULES_INS_DIR}
   # 如果只是独立制作模块需要单独更新软件仓库信息
   [ "${CMD_NAME}" = "modules" ] && sync_database
   [ -f ${EX_MODULE_LIST} ] && rm -f ${EX_MODULE_LIST}
   cat ${PACKLIST}/extra_module_0.list | while read mod; do
	[ ! -d ${EXTRA_MODULES_INS_DIR}/${mod} ] && mkdir -p ${EXTRA_MODULES_INS_DIR}/${mod}
	remount_aufs_w ${EXTRA_MODULES_INS_DIR}/${mod}
	[ "x$mod" = "x" ] && continue
	pkgname=" -d $mod"
	pac_install
	#再只读挂载
	remount_aufs_r ${EXTRA_MODULES_INS_DIR}/${mod}
   	# 导出已经安装的软件清单(独立模块，含版本信息)
	$PACMAN -Q -r ${EXTRA_MODULES_INS_DIR}/${mod} >> ${EX_MODULE_LIST}
   done

   # 卸载UNION
   info "卸载aufs件系统 ${UNION}."
   umount -l ${UNION}

   # 模块清理，删除不需要的文件
   pac_clean
}

function get_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中需要检测依赖关系的软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {dep_pkg=""}{if ($1 !~ /^#+/) {if (NF == 1) {dep_pkg=dep_pkg " " $1}}}END {print dep_pkg}' $1)
}
function get_d_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中无需检测依赖关系的软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {nodep_pkg=""}{if ($1 !~ /^#+/) { if (NF == 2) {nodep_pkg=nodep_pkg " " $2}}}END {print nodep_pkg}' $1)
}
function get_all_pkgname () {
   # $1  软件包清单
   # 该函数将软件包清单中所有软件包以空格相隔返回到变量PKGNAME
   pkgname=$(awk 'BEGIN {all_pkg=""}{if ($1 !~ /^#+/) { {all_pkg=nodep_pkg " " $1" "$2}}}END {print all_pkg}' $1)
}

cmd_install () {

   # 软件清单文件夹
   [ -d ${PACKLIST} ] && rm -R ${PACKLIST}
   mkdir -p ${PACKLIST}

   [ -d ${UNION}/dev ] && rm -rf ${UNION}/dev
   info "开始进行Archlive的制作..."
   info "开始将$LISTDIR里面的软件安装/更新到对应模块文件夹"
   # 更新软件仓库信息
   sync_database
   [ -f ${PACKLIST}/updated.list ] && rm -f ${PACKLIST}/updated.list
   for mod in ${MODULES}; do
	#如果模块名以#开头则忽略
	[ "$(case $mod in \#*) echo 0 ;; esac)" ] && continue
        [ ! -d ${MODULEDIR}/${mod} ] && mkdir -p ${MODULEDIR}/${mod}
	remount_aufs_w ${MODULEDIR}/${mod}	
	
	echo "将模块软件清单整理后输出（去除被#注释的）"
 	cat "${PROFILE_DIR}/$LISTDIR/${mod}.list" | sed -r "s/#.*//g" | sed -r "/^$/d" |sort >${PACKLIST}/${mod}.new
	echo "完成."

	# 如果已经存在对应模块，则将对应软件包及版本信息输出到清单并根据已经安装的软件升级
	pacman_local_data=${MODULEDIR}/${mod}/var/lib/pacman/local
	if [ -d ${pacman_local_data} ] && [ "x$(find ${pacman_local_data} -type f -name "desc")" != "x" ]; then
		$PACMAN -Q -r ${MODULEDIR}/${mod} > ${PACKLIST}/${mod}.old
		echo "已安装的程序及版本信息已导出到文件${PACKLIST}/${mod}.old"
		$PACMAN -Su -f --needed --noconfirm --config "${PACMANCONF}" -fr "${UNION}" >/dev/null
		echo "已有程序升级完成."
		# 安装清单中需要的但没有被安装的软件包
		# 无-d选项的
		pkgname=$(awk 'NR==FNR{a[$1];b[$2]}NR>FNR{if (!($2 in a)) {if (!($1 in a)) {print $0}}}' ${PACKLIST}/${mod}.old ${PACKLIST}/${mod}.new | grep -v "\-d")
		if [ "x$pkgname" != "x" ]; then echo "$pkgname 是新添加的(需要检测依赖关系)，需要安装..."; pac_install; fi
		# 有 -d 选项的
		pkgname=$(awk 'NR==FNR{a[$1];b[$2]}NR>FNR{if (!($2 in a)) {if (!($1 in a)) {print $0}}}' ${PACKLIST}/${mod}.old ${PACKLIST}/${mod}.new | grep "\-d")
		if [ "x$pkgname" != "x" ]; then echo "$pkgname 是新添加的(无需检测依赖关系)，需要安装..."; pac_install; fi
		# 删除已经安装的多余的软件
		pkgname=$(awk 'BEGIN {OFS="\t"}NR==FNR{a[$0];b[$2]}NR>FNR{if (!($1 in b)) {if (!($1 in a)) {print $1}}}' ${PACKLIST}/${mod}.new ${PACKLIST}/${mod}.old)
		if [ "x$pkgname" != "x" ]; then echo "$pkgname 在新清单中没有，需要删除..."; pac_remove; fi
	fi
	if [ "x$(find ${MODULEDIR}/${mod} -type f -name "desc")" = "x" ]; then
		touch ${PACKLIST}/${mod}.old
		if [ "${QUICK_INSTALL}" = "y" ]; then
			get_d_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.list
			if [ "x${pkgname}" != "x" ]; then
				pkgname="-d ${pkgname}"
				pac_install
			fi
			get_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.list
			[ "x${pkgname}" != "x" ] && pac_install
		else
	        	cat  "${PACKLIST}/${mod}.new" | while read pkgname; do
				[ "x$pkgname" = "x" ] && continue
				pac_install
	        	done
		fi
        	if [ -e "${PROFILE_DIR}/$LISTDIR/${mod}.removelist" ]; then
			if [ "${QUICK_INSTALL}" = "y" ]; then
				get_all_pkgname ${PROFILE_DIR}/$LISTDIR/${mod}.removelist
				if [ "x${pkgname}" != "x" ]; then
					pkgname="-d ${pkgname}"
					pac_remove
				fi
			else
	            		cat "${PROFILE_DIR}/$LISTDIR/${mod}.removelist" | grep -v "^#" | while read pkgname; do pac_remove; done
			fi
        	fi
	fi
	# 不用软件包定制也可以本地化支持
	if [ $(echo $mod | grep "base") ] && [ "x${SP_CUSTOM_DIR}" != "x" ]; then
		[ -d ${SP_CUSTOM_DIR} ] && cp -rf ${SP_CUSTOM_DIR}/* $UNION/
		[ -f ${SP_CUSTOM_DIR}/etc/locale.gen ] && chroot $UNION locale-gen
	fi
        if [ -e "${UNION}/etc/ld.so.conf" ]; then
            ldconfig -r ${UNION}
        fi
	# 输出最新模块软件清单
	$PACMAN -Q -r ${MODULEDIR}/${mod} > ${PACKLIST}/mod_${mod}.new
	if [ -f ${PACKLIST}/${mod}.old ]; then
		diff -ruNa ${PACKLIST}/${mod}.old ${PACKLIST}/mod_${mod}.new | grep "^[-,+][a-zA-Z]" > ${PACKLIST}/${mod}.list
		if [ "x$(cat ${PACKLIST}/${mod}.list)" != "x" ]; then
			echo "${mod} 模块更新内容(-表示删除的包，+表示新加入的包)" >>${PACKLIST}/updated.list	
			cat ${PACKLIST}/${mod}.list >>${PACKLIST}/updated.list
		fi
	fi
	# 重新只读挂载以进行下一个模块
	remount_aufs_r ${MODULEDIR}/${mod}

	# 只在安装到包含$module-init-tools 软件包模块时才更新内核依赖关系
	if [ -x ${MODULEDIR}/${mod}/sbin/depmod ]; then
		info "基于${INSTROOT}更新内核依赖关系..."
		chroot ${UNION} depmod -a
		echo "完成!"
	fi

	if [ -f ${MODULEDIR}/${mod}/etc/rc.conf ]; then
		# 备份Arch原始启动关机脚本，以便Larchin安装
		echo "备份Arch原始启动关机脚本，以便Larchin安装"
		for larchsavefile in ${MODULEDIR}/${mod}/etc/{rc.sysinit,rc.shutdown,rc.local}; do
			cp -f ${larchsavefile} ${larchsavefile}.larchsave
		done
		echo "完成!"
   	fi

   done

   #如果附加程序模块已经包含在程序清单中则不另外安装制作，除非archlive.conf中特别设置
   [ "${RE_EXTRAMODULES}" != "y" ] && cmd_extramodules_install

   # 导出已经安装的软件清单
   $PACMAN -Q -r ${UNION} > ${PKGFILE}

   # 卸载UNION
   [ "x$(grep $UNION /proc/mounts)" != "x" ] && info "卸载aufs件系统 ${UNION}." && umount -l ${UNION}

   # 清理不需要的文件
   [ "${RE_EXTRAMODULES}" = "y" ] && pac_clean
}

function mksquashfs_module () {
   echo "将${1}用$MKSQUASHFS进行压缩..."
   [ -d ${1}/usr/share/fonts ] && chmod 755 ${1}/usr/share/fonts
   [ -d ${1}/etc/fonts ] && chmod 755 ${1}/etc/fonts
   OPTION="-noappend ${OPTION}"
   if [ "${QUIET}" = "y" ]; then
	   $MKSQUASHFS ${1} ${2} ${OPTION} >/dev/null
   else
	$MKSQUASHFS ${1} ${2} ${OPTION}
   fi
   chmod 0755 ${2}
   echo "${2}创建完成."
}
cmd_extramodules_squash () {

   info "压缩独立程序模块..."
   if [ "${RE_EXTRAMODULES}" = "y" ]; then
	start=$(date +%s)
   fi
   [ ! -d ${EXTRA_MODULES_TARGET} ] && mkdir -p ${EXTRA_MODULES_TARGET}
   for module_dir in $(ls ${EXTRA_MODULES_INS_DIR}); do
	source_dir="${EXTRA_MODULES_INS_DIR}/${module_dir}"
	target_file="${EXTRA_MODULES_TARGET}/$(ls ${EXTRA_MODULES_INS_DIR}/${module_dir}/var/lib/pacman/local)-$ARCH.${EXT}"
	mksquashfs_module "${source_dir}" "${target_file}"
   done
   [ "${RE_EXTRAMODULES}" = "y" ] && info "独立模块在 $(echo $start $(date +%s) | awk '{ printf "%0.2f",($2-$1)/60 }') 分钟内完成压缩."
}

cmd_squash () {

   info "创建squash模块..."
   start=$(date +%s)

   #squashfs压缩的基本模块存放位置 比如0_000_core-i686.sqfs
   moduleplace="${IMGROOT}/${CDNAME}/base"
   for module_dir in $MODULES; do
	[ "$(case ${module_dir} in \#*) echo 0 ;; esac)" ] && continue
	case ${module_dir} in [1-9]_*) moduleplace="${IMGROOT}/${CDNAME}/modules";; esac
	source_dir="${MODULEDIR}/${module_dir}"
        target_file="${moduleplace}/$(basename ${module_dir})-$ARCH.${EXT}"

	# 如果不存在制作好的模块或者有更新则创建模块  ${PACKLIST}/${module_dir}.list存放对应模块的更新详情
        if [ ! "$(find $IMGROOT/$CDNAME -name $(basename  ${target_file}))" -o "x$(cat ${PACKLIST}/${module_dir}.list)" != "x" ]; then
		mksquashfs_module "${source_dir}" "${target_file}"
	fi
   done

   if [ "${USE_OVERLAY}" = "y" ] && [ -d ${WORK_DIR}/overlay ]; then 
	info "创建附加设置模块overlay.${EXT}..."
	OVERLAY="${WORK_DIR}/overlay"
	mksquashfs_module  "${OVERLAY}" "${IMGROOT}/${CDNAME}/base/overlay.${EXT}"
   fi

   #如果附加程序模块已经包含在程序清单中则不另外安装制作
   [ "${RE_EXTRAMODULES}" != "y" ] && cmd_extramodules_squash

   minutes=$(echo $start $(date +%s) | awk '{ printf "%0.2f",($2-$1)/60 }')
   info "模块在 $minutes 分钟内完成创建."
}

check_kernel () {
   preset_file=$(find $MODULEDIR -type f -name "kern*.preset")
   kver_file=$(find $MODULEDIR -type f -name "kern*.kver")
   right_kver_file="n"
   basedir=""
   case "${preset_file%/*/*/*}" in "${kver_file%/*/*/*}") basedir=${kver_file%/*/*/*} ;; esac
   [ "x$basedir" = "x" ] && error "目标系统无安装内核或者内核安装出错..." && usage 1
   case ${kver_file} in "$basedir$(grep source $preset_file | cut -d " " -f2)") right_kver_file="y";; esac
   if [ "${right_kver_file}" = "y" ]; then
	source ${kver_file} && kernelver=${ALL_kver}
	[ "x$kernelver" = "x" ] && error "目标系统内核安装有误，或者内核程序包有问题..." && usage 1
   fi
   ker_desc=$($PACMAN -Qo $kver_file -r $basedir)
   ker_pkgname=$(echo $ker_desc | cut -d " " -f3)
   ker_pkg_ver=$(echo $ker_desc | cut -d " " -f4)
}
cmd_boot_kernel_image () {

   info "准备archlive内核及内核镜像"

   # 判断archlive内核镜像配置文件是否存在
   [ ! -e "${CPIOCONFIG}" ] && error "错误: live系统启动内核镜像配置文件 '${CPIOCONFIG}' 不存在, 退出." && usage 1

   check_kernel
   info "目标系统内核程序包为 $ker_pkgname 版本 $ker_pkg_ver "

   [ ! -d "${IMGROOT}/${CDNAME}/boot" ] && mkdir -p "${IMGROOT}/${CDNAME}/boot"
   right_ker_file="n"    # KER_FILE 在配置文件archlive.conf中定义，默认为vmlinuz26
   case $(grep "boot/${KER_FILE}" $basedir/var/lib/pacman/local/${ker_pkgname}-${ker_pkg_ver}/files) in boot/$KER_FILE) right_ker_file="y";; esac
   [ "${right_ker_file}" = "n" ] && error "目标系统的内核文件名不是${KER_FILE}，请再次检查配置文件和目标系统的内核程序包..." && usage 1
   [ -f ${basedir}/boot/${KER_FILE} ] && cp -f "${basedir}/boot/${KER_FILE}" "${IMGROOT}/${CDNAME}/boot/${KER_FILE}"
   [ -f "${IMGROOT}/${CDNAME}/boot/${KER_FILE}" ] && echo "已经拷贝内核文件${KER_FILE}到目标镜像文件夹下."

   info "创建${CDNAME}  live系统启动的内核镜像..."
	echo "配置文件 ${CPIOCONFIG}, "
	echo "基于目录 ${basedir}, "
	echo "archlive内核版本 ${kernelver} "

   if [ "${QUIET}" = "y" ]; then append_cmd=">/dev/null"; else append_cmd=""; fi
   sh $MKINITCPIO -c "${CPIOCONFIG}" -b "${basedir}" -k "${kernelver}" -g \
		"${IMGROOT}/${CDNAME}/boot/archlive.img" ${append_cmd}
   if [ $? -ne 0 ]; then
	error "错误: 内核镜像创建失败..."
	usage 1
   else
	info "内核启动镜像制作成功！"
   fi
}

create_base_module (){

   info "创建基本模块archlive.sqfs ..."

   live_dir=./linux-live
   . ${live_dir}/liblinuxlive || exit 1
   LIVECDNAME=${CDNAME}
   ADDLOCALE=$(echo ${REMAIN_LOCALE} | tr "|" " ")

   # 基本目录、临时工作目录
   echo "创建基本模块临时目录${base_module_tree}" | tee -a ${LOG}
   base_module_tree="${MODULEDIR}/archlive"
   [ -d ${base_module_tree} ] && rm -rf ${base_module_tree}
   mkdir -p ${base_module_tree}
   
   # 日志 (比较关键，独立日志)
   [ ! -d ${IMGROOT}/${CDNAME} ] && mkdir -p ${IMGROOT}/${CDNAME}
   [ ! -d ${BUILDLOG} ] && mkdir -p ${BUILDLOG}
   LOG=${BUILDLOG}/create_base_module.log
   [ -f ${LOG} ] && rm -f ${LOG}

   echo "检查目标系统内核版本及模块安装目录" | tee -a ${LOG}
   check_kernel
   if [ "x$(echo $basedir | grep "${WORK_DIR}")" = "x" ]; then
	error "工作目录下还没有安装有内核程序包的模块，或者安装不完整..."
	exit 1
   fi
   kernel_modules_dir=${basedir}/lib/modules/${kernelver}/kernel
   ROOT=${basedir} #rcopy_ex 函数需要此参数

   host_kernel_ver=$(uname -r)
   host_kernel_dep_file=$(find /lib -type f -name "modules.dep")
   host_kernel_dir=${host_kernel_dep_file%/modules.dep}
## -------------------开始创建，准备文件、目录等-----
   echo "创建基本目录" | tee -a ${LOG}
   mkdir -p ${base_module_tree}/{etc,dev,bin,mnt,proc,lib,sys,tmp,var/log} | tee -a ${LOG}

   echo "创建基本设备文件"  | tee -a ${LOG}
   mknod ${base_module_tree}/dev/console c 5 1
   mknod ${base_module_tree}/dev/fb0 c 29 0
   mknod ${base_module_tree}/dev/null c 1 3
   mknod ${base_module_tree}/dev/zero c 1 5
   mknod ${base_module_tree}/dev/ram b 1 1
   mknod ${base_module_tree}/dev/systty c 4 0
   mknod ${base_module_tree}/dev/tty c 5 0
   mknod ${base_module_tree}/dev/fuse c 10 229
   for i in 1 2 3 4 5 6; do
	mknod ${base_module_tree}/dev/tty$i c 4 $i;
   done

   #echo "拷贝文件到基本模块"
   touch ${base_module_tree}/etc/{m,fs}tab
   cat ${live_dir}/liblinuxlive | sed -r 's/^LIVECDNAME=.*/LIVECDNAME="'$LIVECDNAME'"/' > ${base_module_tree}/liblinuxlive
   cp ${live_dir}/{linuxrc,cleanup} ${base_module_tree}
   chmod ago+x ${base_module_tree}/{linuxrc,cleanup}

   cp -a ${live_dir}/fuse/* ${base_module_tree}
   cp -a ${live_dir}/httpfs/* ${base_module_tree}
   cp -a ${live_dir}/posixovl/* ${base_module_tree}
   cp -a ${live_dir}/ntfs-3g/* ${base_module_tree}
   cp -af ${live_dir}/rootfs/* ${base_module_tree}
   rm -f ${base_module_tree}/bin/*

   # 基本模块中使用busybox来替代常用程序，比如vi wget等
   for i in $(${live_dir}/rootfs/bin/busybox --help | grep -v Copyright | grep , | tr , " "); do
	ln -s busybox ${base_module_tree}/bin/$i
   done

   for i in $(ls ${live_dir}/rootfs/bin); do
	rm -f ${base_module_tree}/bin/$i
	cp -f rootfs/bin/$i ${base_module_tree}/bin/$i
   done
   ln -sf bin ${base_module_tree}/sbin

   # 创建相关目录
   mkdir -p ${base_module_tree}/lib/modules/${kernelver}/kernel/fs

   # 拷贝内核模块：文件系统 设备驱动等 
   FS="aufs squashfs fuse isofs udf fat vfat ntfs ext3 ext4 btrfs reiserfs xfs nls"
   BASE_DRIVERS="cdrom ide"
   USB="storage host/ehci-hcd.ko host/ohci-hcd.ko host/uhci-hcd.ko"
   PCMCIA="pcmcia_core.ko pcmcia.ko rsrc_nonstatic.ko yenta_socket.ko"
   for source in fs/${FS} drivers/${BASE_DRIVERS} drivers/usb/${USB} drivers/pcmcia/${PCMCIA}; do
	if [ ! -e ${kernel_modules_dir}/${source} ]; then
		case ${kernelver%-*} in ${host_kernel_ver})
			kernel_modules_dir=${host_kernel_dir}/kernel
   			ROOT=
			;;
		esac
	fi
	rcopy_ex ${kernel_modules_dir}/${source} ${base_module_tree} | tee -a ${LOG}
   done
   # 网卡模块
   for mod in $(list_network_drivers); do
	cat ${kernel_modules_dir%/kernel}/modules.dep | fgrep /$mod.ko | while read mod_dep_line; do
		for dep in $(echo ${mod_dep_line} | tr -d ":"); do
			rcopy_ex $dep ${base_module_tree} | tee -a ${LOG}
		done
	done
   done

   # 加入archlive.conf中设置的语言支持
   if [ "$ADDLOCALE" != "" ]; then
	. ${live_dir}/addlocaleslib
	echo "拷贝locale文件 $ROOT/ ${base_module_tree} $ADDLOCALE" | tee -a ${LOG}
	copylocales $ROOT/ ${base_module_tree} $ADDLOCALE
   fi

   echo "更新基本模块内核模块依赖关系" | tee -a ${LOG}
   depmod -a -b ${base_module_tree}

   echo "用squash压缩基本模块中的usr drivers目录..." | tee -a ${LOG}
   mksquashfs_module ${base_module_tree}/usr ${base_module_tree}/usr.lzm
   chmod ago-x ${base_module_tree}/usr.lzm
   rm -Rf ${base_module_tree}/usr/*
   mksquashfs_module ${base_module_tree}/lib/modules/${kernelver}/kernel/drivers ${base_module_tree}/drivers.lzm
   chmod ago-x ${base_module_tree}/drivers.lzm
   rm -Rf ${base_module_tree}/lib/modules/${kernelver}/kernel/drivers/*

   echo "用squash压缩基本模块..." | tee -a ${LOG}
   mksquashfs_module ${base_module_tree} ${IMGROOT}/${CDNAME}/archlive.sqfs
   chmod ago-x ${IMGROOT}/${CDNAME}/archlive.sqfs
   chmod 0444 "${IMGROOT}/${CDNAME}/archlive.sqfs"
   echo "基本模块archlive.sqfs制作完成!"
}


cmd_img () {

   info "准备制作镜像所需要的程序模块..."

   #判断${IMGROOT}下的模块是否是需要的——由${CONFIG_FILE}: archlive.conf定义
   #如果不需要则备份到${WORK_DIR}/no_need_modules下
   NO_Need_Modules=${WORK_DIR}/no_need_modules
   [ ! -d ${NO_Need_Modules} ] && mkdir -p ${NO_Need_Modules}
   for module_file in $(find ${IMGROOT} -name "*.sqfs") $(find ${IMGROOT} -name "*.lzm"); do
	needed="n"
	case ${module_file} in */overlay.${EXT}) case ${USE_OVERLAY} in y) needed="y" && break;; esac;; esac
	case ${module_file} in */archlive.sqfs) needed="y" && break;; esac
	for needed_module in $(ls ${PACKLIST}/mod_*.new); do
		needed_module=${needed_module%.new}
		needed_module=${needed_module#mod_}
		case ${module_file} in "${needed_module}-$ARCH.${EXT}") needed="y" && break;; esac
	done
	cat ${EX_MODULE_LIST} | while read needed_module; do
		[ "$(case $needed_module in \#*) echo 0 ;; esac)" ] && continue
		case ${module_file} in "${needed_module}-$ARCH.${EXT}") needed="y" && break;; esac
	done
	if [ "$needed" = "n" ]; then
		info "$module_file未在${CONFIG_FILE}中定义，移除到${NO_Need_Modules}下"
		mv -f $module_file ${NO_Need_Modules}/
	fi
   done
   echo "镜像目录模块清理完毕."

   # 拷贝附加程序模块
   if [ -d $EXTRAPACKAGEDIR ]; then
	[ ! -d ${EXTRA_PACKAGE_TARGET} ] && mkdir -p ${EXTRA_PACKAGE_TARGET}
   	for mod in $EXTRAPACKAGEDIR/*.$EXT; do info "拷贝附加程序模块 $mod ..." && cp $mod ${EXTRA_PACKAGE_TARGET}/; done
	echo "完成."
   fi

   echo "将软件清单放到镜像目录中"
   cp -f ${PKGFILE} ${IMGROOT}/${CDNAME}/${CDNAME}.list
   echo "完成."

   info "准备启动文件..."
   bootflags=""
   if [ "$BOOT" = "grub" -o "$BOOT" = "grub-gfx" ]; then
	[ ! -d "${IMGROOT}/boot/grub" ] && mkdir -p "${IMGROOT}/boot/grub"
	bootfile=$(find $MODULEDIR -type f -name "stage2_eltorito")
	if [ ! "x${bootfile}" = "x" ]; then
		cp -f ${bootfile} ${IMGROOT}/boot/grub/
		echo "找到引导程序${bootfile}，使用该引导程序覆盖cd-root里可能已经存在的引导程序."
	else
		if [ -f ${IMGROOT}/boot/grub/stage2_eltorito ]; then
			error "目标系统中没有安装$BOOT，使用cd-root中原来的引导程序..."
		else
			echo "目标系统中没有选择安装$BOOT, 在宿主系统中查找..."
			grub --help 2>&1 >/dev/null
			[ $? -ne 0 ] && error "宿主系统也不存在$BOOT. 无法继续!请选择其他引导程序或者安装$BOOT..." && usage 1
			bootfile=$(find $MODULEDIR -type f -name "stage2_eltorito")
			if [ ! "x${bootfile}" = "x" ]; then
				cp -f ${bootfile} ${IMGROOT}/boot/grub/
				echo "在${bootfile_dir}目录下找到引导程序."
			else 
				error "宿主系统也没有安装$BOOT. 无法继续!请选择其他引导程序或者安装$BOOT..." && usage1
			fi
		fi
	fi
	bootflags="-b boot/grub/stage2_eltorito"
	echo "引导程序$BOOT 准备完毕."
   fi
   if [ "$BOOT" = "syslinux" -o "$BOOT" = "isolinux" ]; then
	[ ! -d ${IMGROOT}/boot/isolinux ] && mkdir -p ${IMGROOT}/boot/isolinux
	bootfile=$(find $MODULEDIR -type f -name "isolinux.bin")
	bootfile_dir=${bootfile%/isolinux.bin}
	if [ ! "x${bootfile_dir}" = "x" ]; then
		cp -f ${bootfile_dir}/*.* ${IMGROOT}/boot/isolinux/
		echo "找到引导程序${bootfile}，使用该引导程序覆盖cd-root里可能已经存在的引导程序."
	else
		if [ -f ${IMGROOT}/boot/isolinux/isolinux.bin ]; then
			warn "目标系统中没有选择安装$BOOT, 使用cd-root中原来的引导程序..."
		else
			echo "目标系统中没有选择安装$BOOT, 在宿主系统中查找..."
			bootfile=$(find /usr -type f -name "isolinux.bin")
			bootfile_dir=${bootfile%/isolinux.bin}
			if [ ! "x${bootfile_dir}" = "x" ]; then
				cp -f ${bootfile_dir}/*.* ${IMGROOT}/boot/isolinux/ 
				echo "在${bootfile_dir}目录下找到引导程序."
			else 
				error "宿主系统也没有安装$BOOT. 无法继续!请选择其他引导程序或者安装$BOOT..." && usage1
			fi
		fi
	fi
	bootflags="-b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat"
	echo "引导程序$BOOT 准备完毕."
   fi
   if [ "$BOOT" = "grub2" ]; then
	[ ! -d ${IMGROOT}/boot/grub ] && mkdir -p ${IMGROOT}/boot/grub
	grub2_mkimg=$(find $MODULEDIR -type f -name "grub-mkimage")
	if [ "x${grub2_mkimg}" = "x" ]; then
		[ ! -x /bin/grub-mkimage ] && error "目标系统及宿主系统中都没有安装grub2，\n 宿主系统安装grub2后再 sudo sh ./$APPNAME img 工作目录 来重新制作镜像。" && usage 1
		grub2_mkimg="/bin/grub-mkimage"
		cp -f /usr/lib/grub/i386-pc/* ${IMGROOT}/boot/grub/
		cp -f /usr/share/grub/* ${IMGROOT}/boot/grub/
	else
		cp -f $(find $MODULEDIR -type d -name "i386-pc")/* ${IMGROOT}/boot/grub/
		cp -f $(find $MODULEDIR -type f -name "*.pf2") ${IMGROOT}/boot/grub/
	fi
	${grub2_mkimg} -d ${IMGROOT}/boot/grub/ -o core.img biosdisk pc gpt iso9660 fat ntfs ext2 pxe\
		reiserfs gfxterm ntfs
	cat ${IMGROOT}/boot/grub/{cdboot.img,core.img} > ${IMGROOT}/boot/grub/grub2cd.bin
	bootflags="-b boot/grub/grub2cd.bin"
	echo "引导程序$BOOT 准备完毕."
   fi
   if [ "$IMG_TYPE" = "img" ]; then
        info "创建USB DISK镜像img..."
        ${START_DIR}/mkusbimg "${IMGROOT}" "${IMGNAME}"
   fi
   echo "IMGROOT=$IMGROOT"
   if [ "$IMG_TYPE" = "iso" ]; then
        info "创建ISO镜像..."
        qflag=""
        [ "${QUIET}" = "y" ] && qflag="-q"
        mkisofs ${qflag} -v -J -R -D -r -l $bootflags -uid 0 -gid 0 \
	    -input-charset utf-8 -p "${AUTHOR}" \
            -no-emul-boot -boot-load-size 4 -boot-info-table \
            -publisher "${PUBLISHER}" \
            -A "${CDNAME}" -V "${CDNAME}" \
            -o "${IMGNAME}" "${IMGROOT}"
       isohybrid "${IMGNAME}"
       md5sum "${IMGNAME}" > "${IMGNAME}".md5
       info "${IMGNAME}制作成功！"
   fi
}
###--------------------------------------主程序调用------------------------------------------------------
case ${CMD_NAME} in
	prepare) cmd_prepare ;;
	install) cmd_prepare; cmd_install ;;
	modules) prepare_pacman; cmd_extramodules_install; cmd_extramodules_squash ;;
	squash) cmd_squash ;;
	boot*) prepare_pacman; cmd_boot_kernel_image ;;
	core_module) create_base_module ;;
	img) cmd_img ;;
	all) cmd_prepare; cmd_install; cmd_squash; cmd_boot_kernel_image; prepare_base_module; cmd_img ;;
esac
info "------------------程序执行结束-------------------------------------"
